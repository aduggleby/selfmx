using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace SelfMX.Api.Authentication;

/// <summary>
/// Verifies SHA-512 crypt hashes in the format $6$salt$hash.
/// Compatible with hashes generated by: openssl passwd -6 "password"
/// Uses native libc crypt on Linux for correct implementation.
/// </summary>
public static class Sha512CryptVerifier
{
    private const string Sha512Prefix = "$6$";

    // P/Invoke to libc crypt function (Linux only)
    [DllImport("libcrypt.so.1", EntryPoint = "crypt", CharSet = CharSet.Ansi)]
    private static extern IntPtr crypt_libcrypt(string key, string salt);

    [DllImport("libc.so.6", EntryPoint = "crypt", CharSet = CharSet.Ansi)]
    private static extern IntPtr crypt_libc(string key, string salt);

    /// <summary>
    /// Verifies a password against a SHA-512 crypt hash.
    /// </summary>
    public static bool Verify(string password, string hash)
    {
        if (string.IsNullOrEmpty(password) || string.IsNullOrEmpty(hash))
            return false;

        if (!hash.StartsWith(Sha512Prefix))
            return false;

        try
        {
            var computed = Crypt(password, hash);
            if (computed == null) return false;

            return CryptographicOperations.FixedTimeEquals(
                Encoding.UTF8.GetBytes(computed),
                Encoding.UTF8.GetBytes(hash));
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Debug method to compute and return the hash for comparison.
    /// </summary>
    public static string ComputeForDebug(string password, string existingHash)
    {
        try
        {
            return Crypt(password, existingHash) ?? "ERROR: crypt returned null";
        }
        catch (Exception ex)
        {
            return $"ERROR: {ex.Message}";
        }
    }

    /// <summary>
    /// Computes a SHA-512 crypt hash using native libc.
    /// </summary>
    private static string? Crypt(string password, string existingHash)
    {
        // Extract the salt portion: $6$salt$ or $6$rounds=N$salt$
        // We pass the full hash as the "salt" parameter - crypt() will extract what it needs
        IntPtr result;

        // Try libcrypt first (Alpine/musl), then libc (glibc)
        try
        {
            result = crypt_libcrypt(password, existingHash);
        }
        catch (DllNotFoundException)
        {
            try
            {
                result = crypt_libc(password, existingHash);
            }
            catch (DllNotFoundException)
            {
                throw new PlatformNotSupportedException(
                    "Neither libcrypt.so.1 nor libc.so.6 with crypt() found. " +
                    "This verifier only works on Linux.");
            }
        }

        if (result == IntPtr.Zero)
            return null;

        return Marshal.PtrToStringAnsi(result);
    }
}
