using System.Security.Cryptography;
using System.Text;

namespace SelfMX.Api.Authentication;

/// <summary>
/// Verifies SHA-512 crypt hashes in the format $6$salt$hash.
/// Compatible with hashes generated by: openssl passwd -6 "password"
/// </summary>
public static class Sha512CryptVerifier
{
    private const string Sha512Prefix = "$6$";
    private const int DefaultRounds = 5000;

    // Custom Base64 alphabet used by crypt(3)
    private const string CryptBase64 =
        "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

    /// <summary>
    /// Verifies a password against a SHA-512 crypt hash.
    /// </summary>
    /// <param name="password">The plain text password to verify</param>
    /// <param name="hash">The SHA-512 crypt hash ($6$salt$hash format)</param>
    /// <returns>True if the password matches the hash</returns>
    public static bool Verify(string password, string hash)
    {
        if (string.IsNullOrEmpty(password) || string.IsNullOrEmpty(hash))
            return false;

        if (!hash.StartsWith(Sha512Prefix))
            return false;

        try
        {
            var computed = Crypt(password, hash);
            return CryptographicOperations.FixedTimeEquals(
                Encoding.UTF8.GetBytes(computed),
                Encoding.UTF8.GetBytes(hash));
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Computes a SHA-512 crypt hash for the given password using the salt from an existing hash.
    /// </summary>
    private static string Crypt(string password, string existingHash)
    {
        // Parse the existing hash to extract salt and rounds
        var parts = existingHash.Split('$');
        if (parts.Length < 4)
            throw new ArgumentException("Invalid hash format");

        int rounds = DefaultRounds;
        string salt;

        // Check for rounds parameter: $6$rounds=N$salt$hash
        if (parts[2].StartsWith("rounds="))
        {
            rounds = int.Parse(parts[2].Substring(7));
            salt = parts[3];
        }
        else
        {
            salt = parts[2];
        }

        // Limit salt to 16 characters
        if (salt.Length > 16)
            salt = salt.Substring(0, 16);

        var passwordBytes = Encoding.UTF8.GetBytes(password);
        var saltBytes = Encoding.UTF8.GetBytes(salt);

        // Compute the hash
        var hashBytes = ComputeSha512Crypt(passwordBytes, saltBytes, rounds);
        var hashString = CryptBase64Encode(hashBytes);

        // Build the result
        if (rounds == DefaultRounds)
            return $"$6${salt}${hashString}";
        else
            return $"$6$rounds={rounds}${salt}${hashString}";
    }

    private static byte[] ComputeSha512Crypt(byte[] password, byte[] salt, int rounds)
    {
        // Step 1-8: Compute digest B
        byte[] digestB;
        using (var sha = SHA512.Create())
        {
            sha.TransformBlock(password, 0, password.Length, null, 0);
            sha.TransformBlock(salt, 0, salt.Length, null, 0);
            sha.TransformFinalBlock(password, 0, password.Length);
            digestB = sha.Hash!;
        }

        // Step 9-12: Compute digest A
        byte[] digestA;
        using (var sha = SHA512.Create())
        {
            sha.TransformBlock(password, 0, password.Length, null, 0);
            sha.TransformBlock(salt, 0, salt.Length, null, 0);

            // Add bytes from B based on password length
            int remaining = password.Length;
            while (remaining > 64)
            {
                sha.TransformBlock(digestB, 0, 64, null, 0);
                remaining -= 64;
            }
            sha.TransformBlock(digestB, 0, remaining, null, 0);

            // Add password or digest B based on bits of password length
            int length = password.Length;
            while (length > 0)
            {
                if ((length & 1) != 0)
                    sha.TransformBlock(digestB, 0, 64, null, 0);
                else
                    sha.TransformBlock(password, 0, password.Length, null, 0);
                length >>= 1;
            }

            sha.TransformFinalBlock([], 0, 0);
            digestA = sha.Hash!;
        }

        // Step 13-15: Compute digest P (password repeated)
        byte[] digestP;
        using (var sha = SHA512.Create())
        {
            for (int i = 0; i < password.Length; i++)
                sha.TransformBlock(password, 0, password.Length, null, 0);
            sha.TransformFinalBlock([], 0, 0);
            digestP = sha.Hash!;
        }

        // Build P sequence
        byte[] p = new byte[password.Length];
        for (int i = 0; i < password.Length; i++)
            p[i] = digestP[i % 64];

        // Step 16-18: Compute digest S (salt repeated)
        byte[] digestS;
        using (var sha = SHA512.Create())
        {
            int count = 16 + digestA[0];
            for (int i = 0; i < count; i++)
                sha.TransformBlock(salt, 0, salt.Length, null, 0);
            sha.TransformFinalBlock([], 0, 0);
            digestS = sha.Hash!;
        }

        // Build S sequence
        byte[] s = new byte[salt.Length];
        for (int i = 0; i < salt.Length; i++)
            s[i] = digestS[i % 64];

        // Step 19-21: Main rounds loop
        byte[] ac = digestA;
        for (int round = 0; round < rounds; round++)
        {
            using var sha = SHA512.Create();

            if ((round & 1) != 0)
                sha.TransformBlock(p, 0, p.Length, null, 0);
            else
                sha.TransformBlock(ac, 0, 64, null, 0);

            if (round % 3 != 0)
                sha.TransformBlock(s, 0, s.Length, null, 0);

            if (round % 7 != 0)
                sha.TransformBlock(p, 0, p.Length, null, 0);

            if ((round & 1) != 0)
                sha.TransformBlock(ac, 0, 64, null, 0);
            else
                sha.TransformBlock(p, 0, p.Length, null, 0);

            sha.TransformFinalBlock([], 0, 0);
            ac = sha.Hash!;
        }

        return ac;
    }

    private static string CryptBase64Encode(byte[] bytes)
    {
        // SHA-512 produces 64 bytes, encoded with specific byte ordering
        var sb = new StringBuilder(86);

        // The encoding order for SHA-512 crypt is specific
        int[] order = {
            0, 21, 42, 1, 22, 43, 2, 23, 44, 3, 24, 45, 4, 25, 46, 5,
            26, 47, 6, 27, 48, 7, 28, 49, 8, 29, 50, 9, 30, 51, 10, 31,
            52, 11, 32, 53, 12, 33, 54, 13, 34, 55, 14, 35, 56, 15, 36,
            57, 16, 37, 58, 17, 38, 59, 18, 39, 60, 19, 40, 61, 20, 41, 62, 63
        };

        // Encode groups of 3 bytes
        for (int i = 0; i < 21; i++)
        {
            int b0 = bytes[order[i * 3]];
            int b1 = bytes[order[i * 3 + 1]];
            int b2 = bytes[order[i * 3 + 2]];

            int value = b0 | (b1 << 8) | (b2 << 16);

            sb.Append(CryptBase64[value & 0x3F]);
            sb.Append(CryptBase64[(value >> 6) & 0x3F]);
            sb.Append(CryptBase64[(value >> 12) & 0x3F]);
            sb.Append(CryptBase64[(value >> 18) & 0x3F]);
        }

        // Last byte (index 63)
        int last = bytes[order[63]];
        sb.Append(CryptBase64[last & 0x3F]);
        sb.Append(CryptBase64[(last >> 6) & 0x3F]);

        return sb.ToString();
    }
}
